ATTRIBUTE = 'attribute'
CONST = 'const'

VOID = 'void'
BOOL = 'bool'
FLOAT = 'float'
INT = 'int'
SAMPLER2D = 'sampler2d'
SAMPLERCUBE = 'samplercube'
STRUCT = 'struct'

BVEC2 = 'bvec2'
BVEC3 = 'bvec3'
BVEC4 = 'bvec4'
IVEC2 = 'ivec2'
IVEC3 = 'ivec3'
IVEC4 = 'ivec4'
VEC2 = 'vec2'
VEC3 = 'vec3'
VEC4 = 'vec4'
MAT2 = 'mat2'
MAT3 = 'mat3'
MAT4 = 'mat4'

IN = 'in'
OUT = 'out'
INOUT = 'inout'

UNIFORM = 'uniform'
VARYING = 'varying'

IF = 'if'
ELSE = 'else'
DO = 'do'
WHILE = 'while'
FOR = 'for'
BREAK = 'break'
CONTINUE = 'continue'
DISCARD = 'discard'
RETURN = 'return'

WHITESPACE = #'\s*'

NONDIGIT = #'[a-zA-z_]'
IDENTIFIER = NONDIGIT *{ NONDIGIT | DIGIT }
TYPE_NAME = VOID | BOOL | INT | FLOAT |
            VEC2 | VEC3 | VEC4 |
            BVEC2 | BVEC3 | BVEC4 |
            IVEC2 | IVEC3 | IVEC4 |
            MAT2 | MAT3 | MAT4 |
            SAMPLER2D | SAMPLERCUBE
NONZERO_DIGIT = #'[1-9]'
OCTAL_DIGIT = #'[0-7]'
HEXADECIMAL_DIGIT = #'[0-9a-fA-F]'
DIGIT = '0' | NONZERO_DIGIT
HEXADECIMAL_CONSTANT = ('0x' | '0X') HEXADECIMAL_DIGIT+
OCTAL_CONSTANT = '0' OCTAL_DIGIT+
DECIMAL_CONSTANT = NONZERO_DIGIT *{DIGIT}
INTEGER_CONSTANT = DECIMAL_CONSTANT | OCTAL_CONSTANT | HEXADECIMAL_CONSTANT
DIGIT_SEQUENCE = DIGIT+
SIGN = '+' | '-'
EXPONENT_PART = #'[eE]' ?[SIGN] DIGIT_SEQUENCE
FRACTIONAL_CONSTANT = DIGIT_SEQUENCE '.' DIGIT_SEQUENCE | DIGIT_SEQUENCE '.' | '.' DIGIT_SEQUENCE
FLOATING_CONSTANT = FRACTIONAL_CONSTANT ?[EXPONENT_PART] | DIGIT_SEQUENCE EXPONENT_PART
BOOL_CONSTANT = 'true' | 'false'
FIELD_SELECTION = IDENTIFIER

LEFT_OP = '<<'
RIGHT_OP = '>>'
INC_OP = '+'
DEC_OP = '-'
LE_OP = '<='
GE_OP = '>='
EQ_OP = '=='
NE_OP = '!='
AND_OP = '&&'
OR_OP = '||'
XOR_OP = '^^'

MUL_ASSIGN = '*='
DIV_ASSIGN = '/='
ADD_ASSIGN = '+='
MOD_ASSIGN = '%='
LEFT_ASSIGN = '<<='
RIGHT_ASSIGN = '>>='
AND_ASSIGN = '&='
XOR_ASSIGN = '^='
OR_ASSIGN = '|='
SUB_ASSIGN = '-='

LEFT_PAREN = '('
RIGHT_PAREN = ')'
LEFT_BRACKET = '['
RIGHT_BRACKET = ']'
LEFT_BRACE = '{'
RIGHT_BRACE = '}'
DOT = '.'
COMMA = ','
COLON = ':'
EQUAL = '='
SEMICOLON = ';'
BANG = '!'
DASH = '-'
TILDE = '~'
PLUS = '+'
STAR = '*'
SLASH = '/'
PERCENT = '%'
LEFT_ANGLE = '<'
RIGHT_ANGLE = '>'
VERTICAL_BAR = '|'
CARET = '^'
AMPERSAND = '&'
QUESTION = '?'

INVARIANT = 'invariant'
HIGH_PRECISION = 'highp'
MEDIUM_PRECISION = 'mediump'
LOW_PRECISION = 'lowp'
PRECISION = 'precision'

VARIABLE_IDENTIFIER = IDENTIFIER
PRIMARY_EXPRESSION = VARIABLE_IDENTIFIER |
                     INTEGER_CONSTANT |
                     FLOATING_CONSTANT |
                     BOOL_CONSTANT |
                     LEFT_PAREN <WHITESPACE> EXPRESSION <WHITESPACE> RIGHT_PAREN
POSTFIX_EXPRESSION = PRIMARY_EXPRESSION |
                     FUNCTION_CALL |
                     POSTFIX_EXPRESSION <WHITESPACE>
                       ( LEFT_BRACKET <WHITESPACE> INTEGER_EXPRESSION <WHITESPACE> RIGHT_BRACKET |
                         DOT <WHITESPACE> FIELD_SELECTION |
                         INC_OP |
                         DEC_OP )
INTEGER_EXPRESSION = EXPRESSION

FUNCTION_CALL = FUNCTION_CALL_GENERIC
FUNCTION_CALL_GENERIC = FUNCTION_CALL_HEADER_WITH_PARAMETERS <WHITESPACE> RIGHT_PAREN |
                        FUNCTION_CALL_HEADER_NO_PARAMETERS <WHITESPACE> RIGHT_PAREN
FUNCTION_CALL_HEADER_NO_PARAMETERS = FUNCTION_CALL_HEADER <WHITESPACE> VOID |
                                     FUNCTION_CALL_HEADER
FUNCTION_CALL_HEADER_WITH_PARAMETERS = FUNCTION_CALL_HEADER <WHITESPACE> ASSIGNMENT_EXPRESSION |
                                       FUNCTION_CALL_HEADER_WITH_PARAMETERS <WHITESPACE> COMMA <WHITESPACE> ASSIGNMENT_EXPRESSION
FUNCTION_CALL_HEADER = FUNCTION_IDENTIFIER LEFT_PAREN
FUNCTION_IDENTIFIER = CONSTRUCTOR_IDENTIFIER | IDENTIFIER
CONSTRUCTOR_IDENTIFIER = IDENTIFIER | TYPE_NAME

UNARY_EXPRESSION = POSTFIX_EXPRESSION |
                   INC_OP <WHITESPACE> UNARY_EXPRESSION |
                   DEC_OP <WHITESPACE> UNARY_EXPRESSION |
                   UNARY_OPERATOR <WHITESPACE> UNARY_EXPRESSION
UNARY_OPERATOR = PLUS | DASH | BANG | TILDE
MULTIPLICATIVE_EXPRESSION = UNARY_EXPRESSION |
                            MULTIPLICATIVE_EXPRESSION <WHITESPACE> ( STAR | SLASH | PERCENT ) <WHITESPACE> UNARY_EXPRESSION
ADDITIVE_EXPRESSION = MULTIPLICATIVE_EXPRESSION |
                      ADDITIVE_EXPRESSION <WHITESPACE> ( PLUS | DASH ) <WHITESPACE> MULTIPLICATIVE_EXPRESSION
SHIFT_EXPRESSION = ADDITIVE_EXPRESSION |
                   SHIFT_EXPRESSION <WHITESPACE> ( LEFT_OP | RIGHT_OP ) <WHITESPACE> ADDITIVE_EXPRESSION
RELATIONAL_EXPRESSION = SHIFT_EXPRESSION |
                        RELATIONAL_EXPRESSION <WHITESPACE> ( LEFT_ANGLE | RIGHT_ANGLE | LE_OP | GE_OP ) <WHITESPACE> SHIFT_EXPRESSION
EQUALITY_EXPRESSION = RELATIONAL_EXPRESSION |
                      EQUALITY_EXPRESSION <WHITESPACE> ( EQ_OP | NE_OP ) <WHITESPACE> RELATIONAL_EXPRESSION
AND_EXPRESSION = EQUALITY_EXPRESSION |
                 AND_EXPRESSION <WHITESPACE> AMPERSAND <WHITESPACE> EQUALITY_EXPRESSION
EXCLUSIVE_OR_EXPRESSION = AND_EXPRESSION |
                          EXCLUSIVE_OR_EXPRESSION <WHITESPACE> CARET <WHITESPACE> AND_EXPRESSION
INCLUSIVE_OR_EXPRESSION = EXCLUSIVE_OR_EXPRESSION |
                          INCLUSIVE_OR_EXPRESSION <WHITESPACE> VERTICAL_BAR <WHITESPACE> EXCLUSIVE_OR_EXPRESSION
LOGICAL_AND_EXPRESSION = INCLUSIVE_OR_EXPRESSION |
                         LOGICAL_AND_EXPRESSION <WHITESPACE> AND_OP <WHITESPACE> INCLUSIVE_OR_EXPRESSION
LOGICAL_XOR_EXPRESSION = LOGICAL_AND_EXPRESSION |
                         LOGICAL_XOR_EXPRESSION <WHITESPACE> XOR_OP <WHITESPACE> LOGICAL_AND_EXPRESSION
LOGICAL_OR_EXPRESSION = LOGICAL_XOR_EXPRESSION |
                        LOGICAL_OR_EXPRESSION <WHITESPACE> OR_OP <WHITESPACE> LOGICAL_XOR_EXPRESSION
CONDITIONAL_EXPRESSION = LOGICAL_OR_EXPRESSION |
                         LOGICAL_OR_EXPRESSION <WHITESPACE> QUESTION <WHITESPACE> EXPRESSION <WHITESPACE> COLON <WHITESPACE> ASSIGNMENT_EXPRESSION
ASSIGNMENT_EXPRESSION = CONDITIONAL_EXPRESSION |
                        UNARY_EXPRESSION <WHITESPACE> ASSIGNMENT_OPERATOR <WHITESPACE> ASSIGNMENT_EXPRESSION
ASSIGNMENT_OPERATOR = EQUAL | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | ADD_ASSIGN |
                      SUB_ASSIGN | LEFT_ASSIGN | RIGHT_ASSIGN | AND_ASSIGN | XOR_ASSIGN | OR_ASSIGN

EXPRESSION = ASSIGNMENT_EXPRESSION |
             EXPRESSION <WHITESPACE> COMMA <WHITESPACE> ASSIGNMENT_EXPRESSION
CONSTANT_EXPRESSION = CONDITIONAL_EXPRESSION
DECLARATION = FUNCTION_PROTOTYPE <WHITESPACE> SEMICOLON |
              INIT_DECLARATOR_LIST <WHITESPACE> SEMICOLON |
              PRECISION <WHITESPACE> PRECISION_QUALIFIER <WHITESPACE> TYPE_SPECIFIER_NO_PREC <WHITESPACE> SEMICOLON

FUNCTION_PROTOTYPE = FUNCTION_DECLARATOR <WHITESPACE> RIGHT_PAREN
FUNCTION_DECLARATOR = FUNCTION_HEADER | FUNCTION_HEADER_WITH_PARAMETERS
FUNCTION_HEADER_WITH_PARAMETERS = FUNCTION_HEADER <WHITESPACE> PARAMETER_DECLARATION |
                                  FUNCTION_HEADER_WITH_PARAMETERS <WHITESPACE> COMMA <WHITESPACE> PARAMETER_DECLARATION
FUNCTION_HEADER = FULLY_SPECIFIED_TYPE <WHITESPACE> IDENTIFIER <WHITESPACE> LEFT_PAREN
PARAMETER_DECLARATOR = TYPE_SPECIFIER <WHITESPACE> IDENTIFIER |
                       TYPE_SPECIFIER <WHITESPACE> IDENTIFIER <WHITESPACE> LEFT_BRACKET <WHITESPACE> CONSTANT_EXPRESSION <WHITESPACE> RIGHT_BRACKET

PARAMETER_DECLARATION = ( TYPE_QUALIFIER <WHITESPACE> | EPSILON ) ?[PARAMETER_QUALIFIER] <WHITESPACE> ( PARAMETER_DECLARATOR | PARAMETER_TYPE_SPECIFIER )
PARAMETER_QUALIFIER = IN | OUT | INOUT
PARAMETER_TYPE_SPECIFIER = TYPE_SPECIFIER |
                           TYPE_SPECIFIER <WHITESPACE> LEFT_BRACKET <WHITESPACE> CONSTANT_EXPRESSION <WHITESPACE> RIGHT_BRACKET

INIT_DECLARATOR_LIST = SINGLE_DECLARATION |
                       INIT_DECLARATOR_LIST <WHITESPACE> COMMA <WHITESPACE> IDENTIFIER ?[ <WHITESPACE>
                         ( LEFT_BRACKET <WHITESPACE> CONSTANT_EXPRESSION <WHITESPACE> RIGHT_BRACKET |
                           EQUAL <WHITESPACE> INITIALIZER ) ]
SINGLE_DECLARATION = FULLY_SPECIFIED_TYPE ?[ <WHITESPACE> IDENTIFIER <WHITESPACE>
                       ( EPSILON |
                         LEFT_BRACKET <WHITESPACE> CONSTANT_EXPRESSION <WHITESPACE> RIGHT_BRACKET |
                         EQUAL <WHITESPACE> INITIALIZER )] |
                     INVARIANT <WHITESPACE> IDENTIFIER

FULLY_SPECIFIED_TYPE = TYPE_SPECIFIER |
                       TYPE_QUALIFIER <WHITESPACE> TYPE_SPECIFIER
TYPE_QUALIFIER = CONST | ATTRIBUTE | VARYING | INVARIANT <WHITESPACE> VARYING | UNIFORM
TYPE_SPECIFIER = TYPE_SPECIFIER_NO_PREC | PRECISION_QUALIFIER <WHITESPACE> TYPE_SPECIFIER_NO_PREC
TYPE_SPECIFIER_NO_PREC = TYPE_NAME | STRUCT_SPECIFIER
PRECISION_QUALIFIER = HIGH_PRECISION | MEDIUM_PRECISION | LOW_PRECISION

STRUCT_SPECIFIER = STRUCT <WHITESPACE> IDENTIFIER <WHITESPACE> LEFT_BRACE <WHITESPACE> STRUCT_DECLARATION_LIST <WHITESPACE> RIGHT_BRACE |
                   STRUCT <WHITESPACE> LEFT_BRACE <WHITESPACE> STRUCT_DECLARATION_LIST <WHITESPACE> RIGHT_BRACE
STRUCT_DECLARATION_LIST = STRUCT_DECLARATION |
                          STRUCT_DECLARATION_LIST <WHITESPACE> STRUCT_DECLARATION
STRUCT_DECLARATION = TYPE_SPECIFIER <WHITESPACE> STRUCT_DECLARATION_LIST <WHITESPACE> SEMICOLON
STRUCT_DECLARATOR_LIST = STRUCT_DECLARATOR |
                         STRUCT_DECLARATOR_LIST <WHITESPACE> COMMA <WHITESPACE> STRUCT_DECLARATOR
STRUCT_DECLARATOR = IDENTIFIER |
                    IDENTIFIER <WHITESPACE> LEFT_BRACKET <WHITESPACE> CONSTANT_EXPRESSION <WHITESPACE> RIGHT_BRACKET

INITIALIZER = ASSIGNMENT_EXPRESSION
DECLARATION_STATEMENT = DECLARATION
STATEMENT_NO_NEW_SCOPE = COMPOUND_STATEMENT_WITH_SCOPE | SIMPLE_STATEMENT
SIMPLE_STATEMENT = DECLARATION_STATEMENT | EXPRESSIONS_STATEMENT |
                   SELECTION_STATEMENT | ITERATION_STATEMENT | JUMP_STATEMENT
COMPOUND_STATEMENT_WITH_SCOPE = LEFT_BRACE <WHITESPACE> RIGHT_BRACE |
                                LEFT_BRACE <WHITESPACE> STATEMENT_LIST <WHITESPACE> RIGHT_BRACE
STATEMENT_WITH_SCOPE = COMPOUND_STATEMENT_NO_NEW_SCOPE |
                       SIMPLE_STATEMENT
COMPOUND_STATEMENT_NO_NEW_SCOPE = LEFT_BRACE RIGHT_BRACE |
                                  LEFT_BRACE <WHITESPACE> STATEMENT_LIST <WHITESPACE> RIGHT_BRACE
STATEMENT_LIST = STATEMENT_NO_NEW_SCOPE |
                 STATEMENT_LIST <WHITESPACE> STATEMENT_NO_NEW_SCOPE
EXPRESSIONS_STATEMENT = SEMICOLON | EXPRESSION SEMICOLON

SELECTION_STATEMENT = IF <WHITESPACE> LEFT_PAREN <WHITESPACE> EXPRESSION <WHITESPACE> RIGHT_PAREN <WHITESPACE> SELECTION_REST_STATEMENT
SELECTION_REST_STATEMENT = STATEMENT_WITH_SCOPE <WHITESPACE> ELSE <WHITESPACE> STATEMENT_WITH_SCOPE |
                           STATEMENT_WITH_SCOPE
CONDITION = EXPRESSION |
            FULLY_SPECIFIED_TYPE <WHITESPACE> IDENTIFIER <WHITESPACE> EQUAL <WHITESPACE> INITIALIZER
ITERATION_STATEMENT = WHILE <WHITESPACE> LEFT_PAREN <WHITESPACE> CONDITION <WHITESPACE> RIGHT_PAREN <WHITESPACE> STATEMENT_NO_NEW_SCOPE |
                      DO <WHITESPACE> STATEMENT_WITH_SCOPE <WHITESPACE> WHILE <WHITESPACE> LEFT_PAREN <WHITESPACE> EXPRESSION <WHITESPACE> RIGHT_PAREN <WHITESPACE> SEMICOLON |
                      FOR <WHITESPACE> LEFT_PAREN <WHITESPACE> FOR_INIT_STATEMENT <WHITESPACE> FOR_REST_STATEMENT <WHITESPACE> RIGHT_PAREN <WHITESPACE> STATEMENT_NO_NEW_SCOPE
FOR_INIT_STATEMENT = EXPRESSIONS_STATEMENT <WHITESPACE> DECLARATION_STATEMENT
FOR_REST_STATEMENT = EPSILON ?[CONDITION] <WHITESPACE> SEMICOLON |
                     EPSILON ?[CONDITION] <WHITESPACE> SEMICOLON <WHITESPACE> EXPRESSION
JUMP_STATEMENT = CONTINUE <WHITESPACE> SEMICOLON |
                 BREAK <WHITESPACE> SEMICOLON |
                 RETURN <WHITESPACE> SEMICOLON |
                 RETURN <WHITESPACE> EXPRESSION <WHITESPACE> SEMICOLON |
                 DISCARD <WHITESPACE> SEMICOLON

TRANSLATION_UNIT = EXTERNAL_DECLARATION <WHITESPACE> | TRANSLATION_UNIT <WHITESPACE> EXTERNAL_DECLARATION <WHITESPACE>
EXTERNAL_DECLARATION = FUNCTION_DEFINITION | DECLARATION
FUNCTION_DEFINITION = FUNCTION_PROTOTYPE <WHITESPACE> COMPOUND_STATEMENT_NO_NEW_SCOPE
